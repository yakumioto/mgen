// Code generated by mgen.
// source:
// {{.ConfigName}}
// DO NOT EDIT

package {{.PackageName}}

//go:generate goimports -w {{.FileName}}
var (
    db *DB
)

type DB struct {
    name    string
    session *mgo.Session
}

func NewDB(name string) *DB {
	if db == nil {
		db = &DB{
			name: name,
		}
	}

	return db
}

func (db *DB) InitDB(session *mgo.Session) {
	if session == nil {
		log.Fatalf("[FATAL] you must connect database\n")
	}
	db.session = session

	log.Printf("[INFO] %v connection succeeded\n", db.name)
}

func GetSessionAndCollection(collection string) (*mgo.Session, *mgo.Collection) {
	s := db.session.Copy()
	c := s.DB(db.name).C(collection)

	return s, c
}

func GetSessionAndGridFS(prefix string) (*mgo.Session, *mgo.GridFS) {
	s := db.session.Copy()
	f := s.DB(db.name).GridFS(prefix)
	return s, f
}


  {{range $_, $Model := .Models}}  {{$name := $Model.Name|ToLower}}{{$Name := $Model.Name}}  {{if .CollectionName}}
const (
    Collection{{$Model.Name}} = "{{$Model.CollectionName}}"
)
  {{if $Model.Types}}
const ({{range $Model.Types}}
    {{$Name}}Type{{.}} = "{{.}}"  {{end}}
)

var (
    {{$Name}}TypesMap = map[string]string{  {{range $Model.Types}}
        {{$Name}}Type{{.}}: "{{.}}",  {{end}}
    }
)

func Check{{$Name}}Type(typename string) bool {
    return {{$Name}}TypesMap[typename] != ""
}
{{end}}  {{if $Model.States}}
const ({{range $Model.States}}
    {{$Name}}State{{.}} = "{{.}}"  {{end}}
)

var (
    {{$Name}}StatesMap = map[string]string{  {{range $Model.States}}
        {{$Name}}State{{.}}: "{{.}}",  {{end}}
    }
)

func Check{{$Name}}States(status string) bool {
    return {{$Name}}StatesMap[status] != ""
}  {{end}}

type {{$Name}} struct {
    ID bson.ObjectId `bson:"_id" json:"_id"`{{range $Model.Fields}}
    {{.Name}} {{.Type}} `bson:"{{.Name|SnakeString}}" json:"{{.Name|SnakeString}},omitempty"{{if .Valid}} valid:"{{.Valid}}"{{end}}`{{end}}
    CreatedAt time.Time `bson:"created_at" json:"created_at"`
    UpdatedAt time.Time `bson:"updated_at" json:"updated_at"`
}

func New{{$Name}}() *{{$Name}}{
    return &{{$Name}}{}
}

func ({{$name}} *{{$Name}}) Insert() error {
    s, c := GetSessionAndCollection(Collection{{$Model.Name}})
    defer s.Close()
    {{range $Model.Fields}}{{if .Unique }}
    if err := c.EnsureIndex(mgo.Index{
        Key: []string{"{{.Name|SnakeString}}"},
        Unique:     true,
        DropDups:   false,
        Background: true,
    }); err != nil {
        return err
    }{{end}}{{end}}

    {{$name}}.ID = bson.NewObjectId()
    {{$name}}.CreatedAt = time.Now().UTC()

    return c.Insert({{$name}})
}

func Update{{$Name}}ByID(id interface{}, {{$name}} *{{$Name}}) error {
    s, c := GetSessionAndCollection(Collection{{$Model.Name}})
    defer s.Close()

    {{$name}}.UpdatedAt = time.Now().UTC()

    switch id := id.(type) {
    case bson.ObjectId:
        return c.UpdateId(id, bson.M{
            "$set": {{$name}},
        })
    case string:
        return c.UpdateId(bson.ObjectIdHex(id), bson.M{
            "$set": {{$name}},
        })
    }

    return errors.New("no bson.ObjectId")
}

func Update{{$Name}}(selector interface{}, {{$name}} *{{$Name}}) error {
    s, c := GetSessionAndCollection(Collection{{$Model.Name}})
    defer s.Close()

    {{$name}}.UpdatedAt = time.Now().UTC()

    return c.Update(selector, bson.M{
        "$set": {{$name}},
    })
}

func Update{{$Name}}All(selector interface{}, {{$name}} *{{$Name}}) (*mgo.ChangeInfo, error) {
    s, c := GetSessionAndCollection(Collection{{$Model.Name}})
    defer s.Close()

    {{$name}}.UpdatedAt = time.Now().UTC()

    return c.UpdateAll(selector, bson.M{
        "$set": {{$name}},
    })
}

func Find{{$Name}}ByID(id interface{}) (*{{$Name}}, error) {
    s, c := GetSessionAndCollection(Collection{{$Model.Name}})
    defer s.Close()

    {{$name}} := new({{$Name}})

    switch id := id.(type) {
    case bson.ObjectId:
    	return {{$name}}, c.FindId(id).One({{$name}})
    case string:
    	return {{$name}}, c.FindId(bson.ObjectIdHex(id)).One({{$name}})
    }

    return nil, errors.New("no bson.ObjectId")
}

func Find{{$Name}}ByQuery(query interface{}) (*{{$Name}}, error) {
    s, c := GetSessionAndCollection(Collection{{$Model.Name}})
    defer s.Close()

    {{$name}} := new({{$Name}})

    return {{$name}}, c.Find(query).One({{$name}})
}

func FindAll{{$Name}}ByQuery(query interface{}) ([]*{{$Name}}, error) {
    s, c := GetSessionAndCollection(Collection{{$Model.Name}})
    defer s.Close()

    {{$name}} := make([]*{{$Name}}, 0)

    return {{$name}}, c.Find(query).All(&{{$name}})
}

func Find{{$Name}}ByFormQuery(fields *storage.Query) ([]*{{$Name}}, error) {
	s, c := GetSessionAndCollection(Collection{{$Model.Name}})
	defer s.Close()

	query := c.Find(fields.Search)

	if len(fields.Sort) != 0 {
		query.Sort(fields.Sort...)
	}

	 {{$name}} := make([]*{{$Name}}, 0)

	return {{$name}}, query.Skip(fields.Skip + (fields.Page * fields.Limt)).
		Limit(fields.Limt).
		All(&{{$name}})
}

func Exist{{$Name}}ByID(id string) (bool, error) {
    s, c := GetSessionAndCollection(Collection{{$Model.Name}})
    defer s.Close()

    {{$name}} := new({{$Name}})

    if err := c.FindId(bson.ObjectIdHex(id)).One({{$name}}); err != nil {
        if err == mgo.ErrNotFound {
            return false, nil
        }
        return false, err
    }

    return true, nil
}

func Exist{{$Name}}ByQuery(query interface{}) (bool, error) {
    s, c := GetSessionAndCollection(Collection{{$Model.Name}})
    defer s.Close()

    {{$name}} := new({{$Name}})

    if err := c.Find(query).One({{$name}}); err != nil {
        if err == mgo.ErrNotFound {
            return false, nil
        }
        return false, err
    }

    return true, nil
}

func Delete{{$Name}}ByID(id string) error {
    s, c := GetSessionAndCollection(Collection{{$Model.Name}})
    defer s.Close()

    return c.RemoveId(bson.ObjectIdHex(id))
}

{{else}}
type {{$Name}} struct { {{range $Model.Fields}}
    {{.Name}} {{.Type}} `bson:"{{.Name|SnakeString}},omitempty" json:"{{.Name|SnakeString}}"`{{end}}
}
{{end}}{{end}}

{{.Raw}}
